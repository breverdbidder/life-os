name: Context Guardian - Prevent Limit Crashes

on:
  schedule:
    - cron: '*/30 * * * *'  # Every 30 minutes
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'check'
        type: choice
        options:
          - check
          - resume
          - list-sessions
      session_id:
        description: 'Session ID (for resume)'
        required: false

env:
  SUPABASE_URL: https://mocerqjnksmhcjzxrewo.supabase.co
  
jobs:
  context-monitor:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: pip install httpx
        
      - name: List Active Sessions
        if: github.event.inputs.action == 'list-sessions' || github.event_name == 'schedule'
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          python << 'EOF'
          import httpx
          import os
          import json
          from datetime import datetime, timedelta, timezone
          
          SUPABASE_URL = os.environ["SUPABASE_URL"]
          SUPABASE_KEY = os.environ["SUPABASE_KEY"]
          
          # Get checkpoints from last 24 hours
          cutoff = (datetime.now(timezone.utc) - timedelta(hours=24)).isoformat()
          
          response = httpx.get(
              f"{SUPABASE_URL}/rest/v1/insights",
              headers={
                  "apikey": SUPABASE_KEY,
                  "Authorization": f"Bearer {SUPABASE_KEY}"
              },
              params={
                  "category": "eq.orchestrator_checkpoint",
                  "created_at": f"gte.{cutoff}",
                  "order": "created_at.desc",
                  "limit": 20
              },
              timeout=30.0
          )
          
          results = response.json()
          print(f"Found {len(results)} checkpoints in last 24h:")
          
          for r in results:
              meta = r.get("metadata", {})
              print(f"  - {meta.get('session_id', 'unknown')}: {r.get('title')} ({meta.get('token_count', 0)} tokens)")
          EOF
          
      - name: Generate Resume Prompt
        if: github.event.inputs.action == 'resume'
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          SESSION_ID: ${{ github.event.inputs.session_id }}
        run: |
          python << 'EOF'
          import httpx
          import os
          import json
          
          SUPABASE_URL = os.environ["SUPABASE_URL"]
          SUPABASE_KEY = os.environ["SUPABASE_KEY"]
          SESSION_ID = os.environ.get("SESSION_ID", "")
          
          if not SESSION_ID:
              print("ERROR: No session_id provided")
              exit(1)
          
          response = httpx.get(
              f"{SUPABASE_URL}/rest/v1/insights",
              headers={
                  "apikey": SUPABASE_KEY,
                  "Authorization": f"Bearer {SUPABASE_KEY}"
              },
              params={
                  "category": "eq.orchestrator_checkpoint",
                  "order": "created_at.desc",
                  "limit": 50
              },
              timeout=30.0
          )
          
          results = response.json()
          
          # Find matching session
          for r in results:
              meta = r.get("metadata", {})
              if meta.get("session_id") == SESSION_ID:
                  content = json.loads(r["content"])
                  print("=" * 60)
                  print("RESUME PROMPT - Copy this to new Claude chat:")
                  print("=" * 60)
                  print(f"""
          RESUMING SESSION: {SESSION_ID}
          
          **Previous Context:**
          {content.get('context_summary', 'N/A')}
          
          **Current Stage:** {content.get('current_stage', 'unknown')}
          
          **Completed Tasks:**
          {json.dumps(content.get('completed_tasks', []), indent=2)}
          
          **Pending Tasks:**
          {json.dumps(content.get('pending_tasks', []), indent=2)}
          
          Continue from where we left off. Do not re-do completed tasks.
          """)
                  print("=" * 60)
                  exit(0)
          
          print(f"Session {SESSION_ID} not found")
          exit(1)
          EOF

      - name: Health Check
        if: github.event.inputs.action == 'check' || github.event_name == 'schedule'
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "âœ… Context Guardian operational"
          echo "Scheduled runs: Every 30 minutes"
          echo "Manual actions: check, resume, list-sessions"
