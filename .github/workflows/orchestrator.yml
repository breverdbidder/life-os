name: Life OS Orchestrator Agent

on:
  workflow_dispatch:
    inputs:
      task:
        description: 'Task to execute'
        required: false
        default: ''
      action:
        description: 'Action: resume, new, status, cloudflare'
        required: true
        default: 'resume'
        type: choice
        options:
          - resume
          - new
          - status
          - cloudflare
  
  schedule:
    - cron: '*/30 * * * *'
  
  repository_dispatch:
    types: [life-os-task]

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  SUPABASE_URL: https://mocerqjnksmhcjzxrewo.supabase.co
  SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
  CF_TOKEN: ${{ secrets.CF_TOKEN }}
  CF_ACCOUNT: 83ab3f2fbbabd1a9b01a018fb4efe219

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install httpx asyncio requests
      
      - name: Check for active checkpoint
        id: checkpoint
        run: |
          RESPONSE=$(curl -s "${{ env.SUPABASE_URL }}/rest/v1/insights?insight_type=eq.SESSION_CHECKPOINT&status=eq.active&order=created_at.desc&limit=1" \
            -H "apikey: ${{ secrets.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_KEY }}")
          
          if echo "$RESPONSE" | python3 -c "import sys,json; d=json.load(sys.stdin); exit(0 if d else 1)" 2>/dev/null; then
            echo "has_checkpoint=true" >> $GITHUB_OUTPUT
            echo "checkpoint_data<<EOF" >> $GITHUB_OUTPUT
            echo "$RESPONSE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Found active checkpoint"
          else
            echo "has_checkpoint=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No active checkpoint"
          fi
      
      - name: Cloudflare Status Check
        id: cloudflare
        if: github.event.inputs.action == 'cloudflare' || github.event.inputs.action == 'status' || github.event_name == 'schedule'
        run: |
          echo "‚òÅÔ∏è Cloudflare Pages Status"
          echo "=========================="
          
          # Fetch directly and process
          python3 << 'PYEOF'
          import json
          import os
          import urllib.request
          
          cf_token = os.environ.get('CF_TOKEN', '')
          cf_account = os.environ.get('CF_ACCOUNT', '')
          
          req = urllib.request.Request(
              f"https://api.cloudflare.com/client/v4/accounts/{cf_account}/pages/projects",
              headers={
                  "Authorization": f"Bearer {cf_token}",
                  "Content-Type": "application/json"
              }
          )
          
          with urllib.request.urlopen(req) as response:
              data = json.loads(response.read().decode())
          
          alerts = []
          for project in data.get("result", []):
              name = project["name"]
              latest = project.get("latest_deployment", {})
              status = latest.get("latest_stage", {}).get("status", "unknown")
              commit = latest.get("deployment_trigger", {}).get("metadata", {}).get("commit_message", "N/A")[:50]
              
              icon = "‚úÖ" if status == "success" else "‚ùå" if status == "failure" else "‚è≥"
              print(f"{icon} {name}: {status}")
              print(f"   URL: {project['subdomain']}")
              print(f"   Last: {commit}")
              print()
              
              if status == "failure":
                  alerts.append(name)
          
          # Write outputs
          github_output = os.environ.get('GITHUB_OUTPUT', '')
          if github_output:
              with open(github_output, 'a') as f:
                  if alerts:
                      f.write("has_alerts=true\n")
                      f.write(f"alert_projects={','.join(alerts)}\n")
                      print(f"‚ö†Ô∏è ALERTS: {', '.join(alerts)} have failed deployments")
                  else:
                      f.write("has_alerts=false\n")
                      print("‚úÖ All deployments healthy")
          PYEOF
      
      - name: Auto-remediate failed deployments
        if: steps.cloudflare.outputs.has_alerts == 'true'
        run: |
          echo "üîß Attempting auto-remediation..."
          for PROJECT in $(echo "${{ steps.cloudflare.outputs.alert_projects }}" | tr ',' ' '); do
            echo "Redeploying $PROJECT..."
            curl -s -X POST "https://api.cloudflare.com/client/v4/accounts/${{ env.CF_ACCOUNT }}/pages/projects/$PROJECT/deployments" \
              -H "Authorization: Bearer ${{ env.CF_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d '{"branch": "main"}' | python3 -c "
          import sys, json
          data = json.load(sys.stdin)
          if data.get('success'):
              print(f\"  ‚úÖ Triggered: {data['result']['short_id']}\")
          else:
              print(f\"  ‚ùå Failed: {data.get('errors')}\")
          "
          done
      
      - name: Run Orchestrator (Resume)
        if: github.event.inputs.action == 'resume' || (github.event_name == 'schedule' && steps.checkpoint.outputs.has_checkpoint == 'true')
        run: |
          python3 << 'EOF'
          import asyncio
          import sys
          sys.path.insert(0, 'agents/orchestrator')
          try:
              from orchestrator import Orchestrator
              
              async def resume():
                  orch = Orchestrator()
                  if await orch.resume_session():
                      result = await orch.execute_task(
                          orch.state.task,
                          [orch.state.current_step] + orch.state.next_steps
                      )
                      print(f"Result: {result}")
                  else:
                      print("No session to resume")
              
              asyncio.run(resume())
          except ImportError as e:
              print(f"Orchestrator not available: {e}")
          EOF
      
      - name: Run Orchestrator (New Task)
        if: github.event.inputs.action == 'new' && github.event.inputs.task != ''
        run: |
          python3 << 'EOF'
          import asyncio
          import os
          import sys
          sys.path.insert(0, 'agents/orchestrator')
          try:
              from orchestrator import Orchestrator
              
              async def new_task():
                  task = "${{ github.event.inputs.task }}"
                  orch = Orchestrator()
                  
                  steps = [
                      f"Analyze requirements for: {task}",
                      f"Execute primary action for: {task}",
                      f"Verify and document results for: {task}"
                  ]
                  
                  result = await orch.execute_task(task, steps)
                  print(f"Result: {result}")
              
              asyncio.run(new_task())
          except ImportError as e:
              print(f"Orchestrator not available: {e}")
          EOF
      
      - name: Status Check
        if: github.event.inputs.action == 'status' || github.event_name == 'schedule'
        run: |
          echo "üìä Life OS Orchestrator Status"
          echo "=============================="
          echo "Checkpoint found: ${{ steps.checkpoint.outputs.has_checkpoint }}"
          echo "Cloudflare alerts: ${{ steps.cloudflare.outputs.has_alerts }}"
      
      - name: Log completion
        if: always()
        run: |
          curl -X POST "${{ env.SUPABASE_URL }}/rest/v1/insights" \
            -H "apikey: ${{ secrets.SUPABASE_KEY }}" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "user_id": 1,
              "insight_type": "ORCHESTRATOR_RUN",
              "title": "Orchestrator execution - ${{ github.run_id }}",
              "description": "{\"trigger\": \"${{ github.event_name }}\", \"action\": \"${{ github.event.inputs.action }}\", \"status\": \"${{ job.status }}\", \"cloudflare_alerts\": \"${{ steps.cloudflare.outputs.has_alerts }}\"}",
              "priority": "low",
              "status": "${{ job.status }}",
              "source": "github_actions"
            }'
