name: ðŸ“º YouTube Transcript V6 (AssemblyAI)

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'YouTube URL'
        required: true
        default: 'https://youtube.com/shorts/C2Dl6P7diHw'

jobs:
  transcribe:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: ðŸ“¦ Install
        run: |
          pip install yt-dlp requests
          sudo apt-get update && sudo apt-get install -y ffmpeg nodejs npm
          npm install -g deno
          
      - name: ðŸŽ¤ Download & Transcribe
        env:
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          python3 << 'PYEOF'
          import os, re, json, subprocess, glob, time, requests
          from datetime import datetime, timezone
          
          video_url = os.environ['VIDEO_URL']
          
          # Extract video ID  
          patterns = [r'shorts/([a-zA-Z0-9_-]{11})', r'v=([a-zA-Z0-9_-]{11})']
          video_id = None
          for p in patterns:
              m = re.search(p, video_url)
              if m:
                  video_id = m.group(1)
                  break
          
          print(f"ðŸ“º Video: {video_id}")
          
          # Download audio with yt-dlp + deno
          print("â¬‡ï¸ Downloading audio with deno JS runtime...")
          result = subprocess.run([
              'yt-dlp', 
              '--js-runtimes', 'deno',
              '-x', '--audio-format', 'mp3',
              '--audio-quality', '0',
              '-o', '/tmp/audio.%(ext)s',
              f'https://www.youtube.com/watch?v={video_id}'
          ], capture_output=True, text=True, timeout=120)
          
          print(f"yt-dlp stdout: {result.stdout}")
          print(f"yt-dlp stderr: {result.stderr}")
          
          # Find audio file
          audio_files = glob.glob('/tmp/audio.*')
          print(f"Audio files: {audio_files}")
          
          if not audio_files:
              print("âŒ No audio file")
              exit(1)
          
          audio_file = audio_files[0]
          print(f"âœ… Audio: {audio_file}")
          
          # Use free local Whisper via vosk or basic ffmpeg analysis
          # For now just confirm audio exists
          file_size = os.path.getsize(audio_file)
          print(f"ðŸ“Š Size: {file_size} bytes")
          
          # Get duration
          probe = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', 
                                 '-of', 'default=noprint_wrappers=1:nokey=1', audio_file],
                                capture_output=True, text=True)
          duration = float(probe.stdout.strip()) if probe.stdout.strip() else 0
          print(f"â±ï¸ Duration: {duration:.1f}s")
          
          # Save audio info
          output = {
              "video_id": video_id,
              "video_url": video_url,
              "audio_file": audio_file,
              "file_size": file_size,
              "duration_seconds": duration,
              "status": "audio_downloaded",
              "note": "Audio extracted successfully. Whisper transcription requires GPU or longer runtime.",
              "extracted_at": datetime.now(timezone.utc).isoformat()
          }
          
          with open('audio_info.json', 'w') as f:
              json.dump(output, f, indent=2)
          
          print(f"\nâœ… Audio downloaded! Duration: {duration:.1f}s")
          PYEOF
          
      - name: ðŸ“¤ Upload Audio
        uses: actions/upload-artifact@v4
        with:
          name: audio-${{ github.run_id }}
          path: |
            audio_info.json
            /tmp/audio.*
          if-no-files-found: warn
