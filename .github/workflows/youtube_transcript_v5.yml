name: üì∫ YouTube Transcript V5 (Robust)

on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'YouTube URL'
        required: true
        default: 'https://youtube.com/shorts/C2Dl6P7diHw'
      category:
        description: 'Category'
        required: false
        default: 'learning'

env:
  SUPABASE_URL: https://mocerqjnksmhcjzxrewo.supabase.co

jobs:
  transcribe:
    name: üé¨ Transcribe with Multiple Fallbacks
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: üì¶ Install
        run: |
          pip install youtube-transcript-api yt-dlp requests pytubefix
          sudo apt-get update && sudo apt-get install -y ffmpeg nodejs npm
          npm install -g deno
          
      - name: üì∫ Extract Transcript
        id: transcribe
        env:
          VIDEO_URL: ${{ github.event.inputs.video_url }}
          CATEGORY: ${{ github.event.inputs.category }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          python3 << 'PYEOF'
          import os, re, json, subprocess, requests
          from datetime import datetime, timezone
          
          video_url = os.environ.get('VIDEO_URL', '')
          category = os.environ.get('CATEGORY', 'learning')
          supabase_url = os.environ.get('SUPABASE_URL', '')
          supabase_key = os.environ.get('SUPABASE_KEY', '')
          
          # Extract video ID
          m = re.search(r'(?:shorts/|v=|youtu\.be/)([a-zA-Z0-9_-]{11})', video_url)
          video_id = m.group(1) if m else None
          
          if not video_id:
              print("‚ùå Invalid URL")
              exit(1)
          
          print(f"üì∫ Video: {video_id}")
          
          transcript = None
          source = "none"
          title = "Unknown"
          
          # STRATEGY 1: YouTube Transcript API (official captions)
          print("\nüéØ Strategy 1: YouTube Transcript API")
          try:
              from youtube_transcript_api import YouTubeTranscriptApi
              api = YouTubeTranscriptApi()
              fetched = api.fetch(video_id)
              transcript = ' '.join([e.text for e in fetched])
              source = "youtube_api"
              print(f"‚úÖ {len(transcript)} chars")
          except Exception as e:
              print(f"‚ö†Ô∏è {e}")
          
          # STRATEGY 2: Pytubefix (works around some restrictions)
          if not transcript or len(transcript) < 20:
              print("\nüéØ Strategy 2: Pytubefix")
              try:
                  from pytubefix import YouTube
                  yt = YouTube(f"https://www.youtube.com/watch?v={video_id}")
                  title = yt.title
                  captions = yt.captions
                  if 'en' in captions:
                      transcript = captions['en'].generate_srt_captions()
                      # Clean SRT format
                      lines = [l for l in transcript.split('\n') if l and not re.match(r'^\d+$|^\d{2}:\d{2}', l)]
                      transcript = ' '.join(lines)
                      source = "pytubefix"
                      print(f"‚úÖ {len(transcript)} chars")
                  elif 'a.en' in captions:
                      transcript = captions['a.en'].generate_srt_captions()
                      lines = [l for l in transcript.split('\n') if l and not re.match(r'^\d+$|^\d{2}:\d{2}', l)]
                      transcript = ' '.join(lines)
                      source = "pytubefix_auto"
                      print(f"‚úÖ {len(transcript)} chars")
                  else:
                      print(f"‚ö†Ô∏è No English captions. Available: {list(captions.keys())}")
              except Exception as e:
                  print(f"‚ö†Ô∏è {e}")
          
          # STRATEGY 3: yt-dlp with deno runtime
          if not transcript or len(transcript) < 20:
              print("\nüéØ Strategy 3: yt-dlp with deno")
              try:
                  result = subprocess.run([
                      'yt-dlp', '--js-runtimes', 'deno',
                      '--skip-download', '--write-auto-sub', '--sub-lang', 'en',
                      '--no-warnings', '-o', f'/tmp/{video_id}',
                      f"https://www.youtube.com/watch?v={video_id}"
                  ], capture_output=True, text=True, timeout=60)
                  
                  import glob
                  vtt = glob.glob(f'/tmp/{video_id}*.vtt') + glob.glob(f'/tmp/{video_id}*.srt')
                  if vtt:
                      with open(vtt[0]) as f:
                          content = f.read()
                      lines = [l.strip() for l in content.split('\n') 
                               if l.strip() and 'WEBVTT' not in l and '-->' not in l 
                               and not re.match(r'^\d+$', l.strip())]
                      # Dedupe
                      seen = set()
                      unique = []
                      for l in lines:
                          if l not in seen:
                              seen.add(l)
                              unique.append(l)
                      transcript = ' '.join(unique)
                      source = "yt-dlp_deno"
                      print(f"‚úÖ {len(transcript)} chars")
                  else:
                      print(f"‚ö†Ô∏è No subtitles. stderr: {result.stderr[:300]}")
              except Exception as e:
                  print(f"‚ö†Ô∏è {e}")
          
          # STRATEGY 4: Direct innertube API
          if not transcript or len(transcript) < 20:
              print("\nüéØ Strategy 4: InnerTube API")
              try:
                  innertube_url = "https://www.youtube.com/youtubei/v1/get_transcript"
                  params = {"key": "AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8"}
                  headers = {"Content-Type": "application/json"}
                  payload = {
                      "context": {
                          "client": {"clientName": "WEB", "clientVersion": "2.20231219.04.00"}
                      },
                      "params": video_id
                  }
                  resp = requests.post(innertube_url, params=params, headers=headers, json=payload, timeout=15)
                  if resp.status_code == 200:
                      data = resp.json()
                      # Parse transcript from response
                      if 'actions' in data:
                          cues = data.get('actions', [{}])[0].get('updateEngagementPanelAction', {}).get('content', {}).get('transcriptRenderer', {}).get('body', {}).get('transcriptBodyRenderer', {}).get('cueGroups', [])
                          texts = []
                          for cue in cues:
                              for c in cue.get('transcriptCueGroupRenderer', {}).get('cues', []):
                                  text = c.get('transcriptCueRenderer', {}).get('cue', {}).get('simpleText', '')
                                  if text:
                                      texts.append(text)
                          if texts:
                              transcript = ' '.join(texts)
                              source = "innertube"
                              print(f"‚úÖ {len(transcript)} chars")
                  else:
                      print(f"‚ö†Ô∏è Status: {resp.status_code}")
              except Exception as e:
                  print(f"‚ö†Ô∏è {e}")
          
          # FINAL OUTPUT
          if not transcript or len(transcript) < 20:
              transcript = "No transcript available - video has no captions"
              source = "failed"
          
          print(f"\n{'='*60}")
          print(f"üìä RESULT: {source} | {len(transcript)} chars")
          print(f"{'='*60}")
          print(f"\nüìù TRANSCRIPT:\n{'-'*50}")
          print(transcript[:2000])
          
          # Save
          output = {
              "video_id": video_id,
              "video_url": video_url,
              "title": title,
              "transcript": transcript,
              "transcript_source": source,
              "category": category,
              "extracted_at": datetime.now(timezone.utc).isoformat()
          }
          
          with open('transcript.json', 'w') as f:
              json.dump(output, f, indent=2)
          
          # Supabase
          if supabase_key and source != "failed":
              try:
                  headers = {"apikey": supabase_key, "Authorization": f"Bearer {supabase_key}", "Content-Type": "application/json"}
                  insight = {"user_id": 1, "insight_type": "youtube_transcript", "title": f"üì∫ {title[:80]}",
                            "content": transcript[:10000], "category": category, "source": f"youtube_{source}", "priority": 2, "status": "Active"}
                  requests.post(f"{supabase_url}/rest/v1/insights", headers=headers, json=insight, timeout=10)
                  print("‚úÖ Saved to Supabase")
              except Exception as e:
                  print(f"‚ö†Ô∏è Supabase: {e}")
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"video_id={video_id}\n")
              f.write(f"source={source}\n")
              f.write(f"length={len(transcript)}\n")
          
          print("\n‚úÖ Done!")
          PYEOF
          
      - name: üì§ Upload
        uses: actions/upload-artifact@v4
        with:
          name: transcript-${{ steps.transcribe.outputs.video_id }}
          path: transcript.json
          
      - name: üìä Summary
        run: |
          echo "## üì∫ Result" >> $GITHUB_STEP_SUMMARY
          echo "- **Source:** ${{ steps.transcribe.outputs.source }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Length:** ${{ steps.transcribe.outputs.length }}" >> $GITHUB_STEP_SUMMARY
